import { LRPCEngine } from "../lrpc";
import fs from 'fs';


export const serviceHandlerPromises = [];
export const typeLibrary = {};
var clientScript = ``;
var serviceClient = ``;


const generateClientCode = (controllerName, className, methodName, request, response) => {

    return`
        static async ${className}(data: ${request.name}, token?: string): Promise<${response.name}> {

            try {

                const dataKey = '${LRPCEngine.instance.service}.${controllerName}.${className}';

                const response = await request(dataKey, data, token);

                return response.data;
            } catch (error) {
                return {
                    message: (error as any).message,
                    status: 'error'
                }
            }
        }`
}

const generateServiceCode = (controllerName, className, methodName, request, response) => {

    return `
        ${className}: {
            request: async (data: ${request.name}, token?: string): Promise<${response.name}> => {

                try {
    
                    const procedure = '${LRPCEngine.instance.service}.${controllerName}.${className}';
    
                    const response = await request(procedure, data, token);
    
                    return response.data;
                } catch (error) {
                    return {
                        message: (error as any).message,
                        status: 'error'
                    }
                }
            },
            queue: async (data: ${request.name}, token?: string): Promise<${response.name}> => {
                return new Promise((resolve, reject)=>{
                    try {
        
                        const procedure = '${LRPCEngine.instance.service}.${controllerName}.${className}';
        
                        const response = queue(procedure, data, token);
        
                        resolve(response);
                    } catch (error) {
                        reject({
                            message: (error as any).message,
                            status: 'error'
                        });
                    }
                });
            
            }
        },
    `
}


export const createServiceClient = (url: string)=>{
    const controllerMaps = {};
    setTimeout(async () => {
        const header = `//Automatically generated by LRPC do not edit\nimport axios from 'axios';\nimport { LRPCEngine } from '../lrpc/engine';\n`;
        
        const controllers = [];
        await Promise.all(serviceHandlerPromises.map(async p => {
            const result = await p();
            const {controller, methodName, name, request, response} = result;
            const script = generateServiceCode(controller, methodName, name, request, response);
            result.script = script;
            // console.log(result.controller, 'done');
            if(!controllerMaps[result.controller]){
                controllerMaps[result.controller] = `
    export const ${result.controller} = {\n${result.script}`;
            } else {
                controllerMaps[result.controller] += `\t${result.script}\n`
            }

            if(!controllers.includes(result.controller)){
                controllers.push(result.controller);
            }

        }));
        // console.log(controllers, 'done');

        const allScripts = await Promise.all(Object.keys(controllerMaps).map(async controller=>{
            let script = controllerMaps[controller];
            script += `\n}`;

            let types = '';
            for(const key in typeLibrary[controller]){
                types += `\n${typeLibrary[controller][key]}`;
            }

            script += `\n ${types}`;

            return script;
        }));

        let footer = 
`\n\ttype Status = 'success' | 'error' | 'unauthorized' | 'notFound' | 'restricted' | 'validationError';`

footer +=  `
    export const request = async (procedure: string, data: any, token?: string) => {
        const response = await axios.post('${url}', {
                path: procedure,
                data
            },
            {
                headers: {
                    Authorization: 'Bearer ' + token
                }
            });
        return response;
    }

    export const queue = async (procedure: string, data: any, token?: string): Promise<any> => {
        const response = await LRPCEngine.instance.Queue.add({
            path: procedure,
            token,
            data
        });
        return response;
    }

    // export const controllers = [${controllers.join(',')}]

`
    serviceClient = header + allScripts.join('\n\n') + footer;
        // const folder = `./src/serviceClients`;
            // if(!fs.existsSync(folder)){
            //     fs.mkdirSync(folder);
            // }
            // fs.writeFileSync(`./src/serviceClients/${LRPCEngine.instance.service}.ts`, serviceClient);
            LRPCEngine.instance.redis.set(`${LRPCEngine.instance.service}_sc`, serviceClient);
            LRPCEngine.instance.redis.sadd('lrpc_services', LRPCEngine.instance.service);
    }, 1000);
}

export const createFEClient = (url: string)=>{
    const controllerMaps = {};

    return new Promise((resolve, reject)=>{
    setTimeout(async () => {
        const header = `//Automatically generated by LRPC do not edit\nimport axios from 'axios';\n\n`;
        
        const controllers = [];
        await Promise.all(serviceHandlerPromises.map(async p => {
            const result = await p();
            const {controller, methodName, name, request, response} = result;
            const script = generateClientCode(controller, methodName, name, request, response);
            result.script = script;
            // console.log(result.controller, 'done');
            if(!controllerMaps[result.controller]){
                controllerMaps[result.controller] = `
    export class ${result.controller} {\n${result.script}`;
            } else {
                controllerMaps[result.controller] += `\t${result.script}\n`
            }

            if(!controllers.includes(result.controller)){
                controllers.push(result.controller);
            }

        }));
        // console.log(controllers, 'done');

        const allScripts = await Promise.all(Object.keys(controllerMaps).map(async controller=>{
            let script = controllerMaps[controller];
            script += `\n}`;

            let types = '';
            for(const key in typeLibrary[controller]){
                types += `\n${typeLibrary[controller][key]}`;
            }

            script += `\n ${types}`;

            return script;
        }));

        let footer = 
`\n\ttype Status = 'success' | 'error' | 'unauthorized' | 'notFound' | 'restricted' | 'validationError';`

footer +=  `
    export const request = async (procedure: string, data: any, token?: string) => {
        const response = await axios.post('${url}', {
                path: procedure,
                data
            },
            {
                headers: {
                    Authorization: 'Bearer ' + token
                }
            });
        return response;
    }

    // export const controllers = [${controllers.join(',')}]

`
        clientScript = header + allScripts.join('\n\n') + footer;
        const folder = `./src/clientsFE`;
            // if(!fs.existsSync(folder)){
            //     fs.mkdirSync(folder);
            // }
            // fs.writeFileSync(`./src/clientsFE/${LRPCEngine.instance.service}.ts`, clientScript);
            LRPCEngine.instance.redis.set(`${LRPCEngine.instance.service}`, serviceClient);
            LRPCEngine.instance.redis.sadd('lrpc_services', LRPCEngine.instance.service);
        resolve("done");
    }, 1000);
});
}

export const fetchClientScript = ()=>{
    return clientScript;
}

export const fetchServiceClient = ()=>{
    return serviceClient;
}
