const fs = require('fs');


const serviceHandlerPromises = [];
const typeLibrary = {};
var clientScript = ``;
var serviceClient = ``;


const generateClientCode = (controllerName, className, methodName, request, response, LRPC) => {

    return`
        static async ${className}(data: ${request.name}, token?: string): Promise<${response.name}> {

            try {

                const dataKey = '${LRPC.service}.${controllerName}.${className}';

                const response = await request(dataKey, data, token);

                return response.data;
            } catch (error) {
                return {
                    message: (error as any).message,
                    status: 'error'
                }
            }
        }`
}

const generateServiceCode = (controllerName, className, methodName, request, response, LRPC, isAuth) => {
    return `
        ${className}: {
            ${isAuth ? `auth: '${isAuth}',` : ''}
            request: async (data: ${request.name}, token?: string): Promise<${response.name}> => {

                try {
    
                    const procedure = '${LRPC.service}.${controllerName}.${className}';
    
                    const response = await request(procedure, data, token);
    
                    return response.data;
                } catch (error) {
                    return {
                        message: (error as any).message,
                        status: 'error'
                    }
                }
            },
            queue: async (data: ${request.name}, token?: string): Promise<${response.name}> => {
                return new Promise((resolve, reject)=>{
                    try {
        
                        const procedure = '${LRPC.service}.${controllerName}.${className}';
        
                        const response = queue(procedure, data, token);
        
                        resolve(response);
                    } catch (error) {
                        reject({
                            message: (error as any).message,
                            status: 'error'
                        });
                    }
                });
            
            }
        },
    `
}


const createServiceClient = (url, LRPC)=>{
    const controllerMaps = {};
    setTimeout(async () => {
        const header = `//Automatically generated by LRPC do not edit\nimport axios from 'axios';\nimport { LRPCEngine } from 'mrn-lrpc';\n`;
        
        const controllers = [];
        const permissions = {};
        await Promise.all(serviceHandlerPromises.map(async p => {
            const result = await p();
            const {controller, methodName, name, request, response, isAuth} = result;
            const script = generateServiceCode(controller, methodName, name, request, response, LRPC, isAuth);
            result.script = script;


            const permissionKey =`${LRPC.service}.${controller}`;
            let permission = permissions[permissionKey];

            if(!permission){
                permissions[permissionKey] = {
                    endpoints: {
                        [methodName]: true
                    },
                    limit: 0,
                    resources: []
                }
            } else {
                permission.endpoints[methodName] = true;
            }
            // console.log(result.controller, 'done');
            if(!controllerMaps[result.controller]){
                controllerMaps[result.controller] = `
    export const ${result.controller} = {\n${result.script}`;
            } else {
                controllerMaps[result.controller] += `\t${result.script}\n`
            }

            if(!controllers.includes(result.controller)){
                controllers.push(result.controller);
            }

        }));
        // console.log(controllers, 'done');

        const allScripts = await Promise.all(Object.keys(controllerMaps).map(async controller=>{
            let script = controllerMaps[controller];
            script += `\n}`;

            let types = '';
            for(const key in typeLibrary[controller]){
                types += `\n${typeLibrary[controller][key]}`;
            }

            script += `\n ${types}`;

            return script;
        }));

        let footer = 
`\n\ttype Status = 'success' | 'error' | 'unauthorized' | 'notFound' | 'restricted' | 'validationError';`

footer +=  `
    export const request = async (procedure: string, data: any, token?: string) => {
        const response = await axios.post('${url}', {
                path: procedure,
                data
            },
            {
                headers: {
                    Authorization: 'Bearer ' + token
                }
            });
        return response;
    }

    export const queue = async (procedure: string, data: any, token?: string): Promise<any> => {
        const response = await LRPCEngine.instance.Queue.add({
            path: procedure,
            token,
            data
        });
        return response;
    }

    export default {${controllers.join(',')}}

`
    serviceClient = header + allScripts.join('\n\n') + footer;
        // const folder = `./src/serviceClients`;
        //     if(!fs.existsSync(folder)){
        //         fs.mkdirSync(folder);
        //     }
        //     fs.writeFileSync(`./src/serviceClients/${LRPC.service}.ts`, serviceClient);
    fs.writeFileSync(`./src/lrpc/serviceClients/${LRPC.service}.access.json`, JSON.stringify(permissions, null, 2));
            LRPC.redis.set(`${LRPC.service}_sc`, serviceClient);
            LRPC.redis.sadd('lrpc_services', LRPC.service);
    }, 1000);
}

const createFEClient = (url, LRPC)=>{
    const controllerMaps = {};

    return new Promise((resolve, reject)=>{
    setTimeout(async () => {
        const header = `//Automatically generated by LRPC do not edit\nimport axios from 'axios';\n\n`;
        
        const controllers = [];
        await Promise.all(serviceHandlerPromises.map(async p => {
            const result = await p();
            const {controller, methodName, name, request, response} = result;
            const script = generateClientCode(controller, methodName, name, request, response, LRPC);
            result.script = script;
            // console.log(result.controller, 'done');
            if(!controllerMaps[result.controller]){
                controllerMaps[result.controller] = `
    export class ${result.controller} {\n${result.script}`;
            } else {
                controllerMaps[result.controller] += `\t${result.script}\n`
            }

            if(!controllers.includes(result.controller)){
                controllers.push(result.controller);
            }

        }));
        // console.log(controllers, 'done');

        const allScripts = await Promise.all(Object.keys(controllerMaps).map(async controller=>{
            let script = controllerMaps[controller];
            script += `\n}`;

            let types = '';
            for(const key in typeLibrary[controller]){
                types += `\n${typeLibrary[controller][key]}`;
            }

            script += `\n ${types}`;

            return script;
        }));

        let footer = 
`\n\ttype Status = 'success' | 'error' | 'unauthorized' | 'notFound' | 'restricted' | 'validationError';`

footer +=  `
    export const request = async (procedure: string, data: any, token?: string) => {
        const response = await axios.post('${LRPC.apiGateWay}', {
                path: procedure,
                data
            },
            {
                headers: {
                    Authorization: 'Bearer ' + token
                }
            });
        return response;
    }

    // export const controllers = [${controllers.join(',')}]

`
        clientScript = header + allScripts.join('\n\n') + footer;
        const folder = `./src/lrpc/clientsFE`;
            if(!fs.existsSync(folder)){
                fs.mkdirSync(folder, { recursive: true });
            }
            fs.writeFileSync(`./src/lrpc/clientsFE/${LRPC.service}.ts`, clientScript);
            LRPC.redis.set(`${LRPC.service}`, serviceClient);
            LRPC.redis.sadd('lrpc_services', LRPC.service);
        resolve("done");
    }, 1000);
});
}

const fetchClientScript = ()=>{
    return clientScript;
}

const fetchServiceClient = ()=>{
    return serviceClient;
}

module.exports = {
    serviceHandlerPromises,
    typeLibrary,
    generateClientCode,
    generateServiceCode,
    createServiceClient,
    createFEClient,
    fetchClientScript,
    fetchServiceClient
}
